<meta id="authenticity-token" name="authenticity-token" content="<%= form_authenticity_token %>">

<h2>Drafty</h2>

<div>
  <%= link_to "Nahrať import", upload_new_message_drafts_imports_path %>
</div>

<% if @message_drafts.any? %>
  <br />
  <h3>Podania</h3>
  <div>
    <table>
      <tr>
        <th>Podanie</th>
        <th>Balík</th>
        <th>Stav</th>
      </tr>

      <% @message_drafts.each do |message_draft| %>
        <tr>
          <td><%= link_to message_draft.title || "Draft", message_draft_path(message_draft.id) %></td>
          <td><%= " #{message_draft.import&.base_name || '-'}" %></td>
          <td><%= " #{message_draft.metadata["status"]}" %></td>
        </tr>
      <% end %>
    </table>
  </div>

  <% if @message_drafts.map{|message_draft| message_draft.objects.should_be_signed.map{|o| {id: o.id, message_id: o.message_id}}}.flatten(1).any? %>
    <button id="sign_objects" type="button" class="flex justify-end items-center gap-2.5 px-3.5 py-2.5 rounded-md bg-white border border-gray-300">
      <b>Podpísať všetky dokumenty na podpis</b>
    </button>
  <% end %>
<% end %>


<script type="text/javascript">
  var objectsToBeSigned = <%= @message_drafts.map{|message_draft| message_draft.objects.should_be_signed.map{|o| {id: o.id, message_id: o.message_id}}}.flatten(1).to_json.html_safe %>;

  // TODO delete all code bellow after separating it to JS file (same code as in message_drafts_component)
  function signObjects() {
    fetch("http://localhost:37200/batch", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify({
        "totalNumberOfDocuments": objectsToBeSigned.length
      })
    }).then(function (response) {
      return response.json();
    }).then(function (data) {
      return data.batchId;
    }).then(async function (batchId) {
      for(const object of objectsToBeSigned) {
        await sign(object.id, object.message_id, batchId);
      }
    }).catch(function (err) {
      if (err.message === "Failed to fetch") {
        alert("Spustite aplikáciu autogram.")
      }
    });
  }

  async function sign(messageObjectId, messageId, batchId = null) {
    return new Promise((resolve, reject) => {
      fetch(`/messages/${messageId}/message_objects/${messageObjectId}/signing_data.json`)
        .then(function (response) {
          return response.json();
        })
        .then(async function (messageObjectData) {
          let payloadMimeType = `${messageObjectData.mime_type};base64`;
          let signatureLevel = "XAdES_BASELINE_B";
          let signatureContainer = "ASiC_E";

          let signedFileName = await setSignedFileName(messageObjectData);
          let signedFileMimeType = "application/vnd.etsi.asic-e+zip";

          switch(messageObjectData.mime_type) {
            case "application/pdf":
              signatureLevel = "PAdES_BASELINE_B";
              signatureContainer = null;

              signedFileName = messageObjectData.file_name;
              signedFileMimeType = messageObjectData.mime_type;
              break;
            // TODO check what in this case
            // case 'application/xml':
            //   break;
            case 'application/x-eform-xml':
              payloadMimeType = "application/xml;base64"
              break;
            case 'application/msword':
            case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
              payloadMimeType = "application/vnd.openxmlformats-officedocument.wordprocessingml.document;base64"
              break;
            case 'image/jpeg':
            case 'image/tiff':
            case 'image/png':
              signatureLevel = "CAdES_BASELINE_B";
              break;
          }

          fetch("http://localhost:37200/sign", {
            method: "POST",
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
              batchId: batchId,
              document: {
                filename: messageObjectData.file_name,
                content: messageObjectData.content
              },
              parameters: {
                level: signatureLevel,
                container: signatureContainer,
                identifier: messageObjectData.identifier,
                schema: messageObjectData.schema,
                containerXmlns: messageObjectData.container_xmlns,
                transformation: messageObjectData.transformation
              },
              payloadMimeType: payloadMimeType
            })
          }).then(function (response) {
            return response.json();
          }).then(function (signedData) {
            updateObject(messageObjectId, messageId, signedFileName, signedFileMimeType, signedData.content);
          }).then(function () {
            resolve();
          })
        })
    });
  }

  async function updateObject(messageObjectId, messageId, signedFileName, signedFileMimeType, signedContent) {
    return new Promise((resolve, reject) => {
      fetch(`/messages/${messageId}/message_objects/${messageObjectId}`, {
        method: "PATCH",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({
          authenticity_token: authenticityToken,
          name: signedFileName,
          mimetype: signedFileMimeType,
          is_signed: true,
          content: signedContent
        })
      }).then(function () {
        resolve();
      })
    });
  }

  async function setSignedFileName(messageObjectData) {
    return messageObjectData.file_name.substring(0, messageObjectData.file_name.lastIndexOf('.')).concat(".asice") || messageObjectData.file_name;
  }

  var signObjectsButton = document.querySelector("#sign_objects");
  if (signObjectsButton) {
    signObjectsButton.onclick = signObjects;
  }

  var authenticityToken = document.getElementById('authenticity-token').getAttribute('content')
</script>
